/* parser.vala.c generated by valac 0.56.3, the Vala compiler
 * generated from parser.vala, do not modify */

/* parser.vala*/

#include <glib-object.h>
#include <glib.h>
#include <stdlib.h>
#include <string.h>
#include <stdio.h>
#include <gobject/gvaluecollector.h>

#if !defined(VALA_EXTERN)
#if defined(_MSC_VER)
#define VALA_EXTERN __declspec(dllexport) extern
#elif __GNUC__ >= 4
#define VALA_EXTERN __attribute__((visibility("default"))) extern
#else
#define VALA_EXTERN extern
#endif
#endif

#define TYPE_PARSER (parser_get_type ())
#define PARSER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARSER, Parser))
#define PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARSER, ParserClass))
#define IS_PARSER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARSER))
#define IS_PARSER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARSER))
#define PARSER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARSER, ParserClass))

typedef struct _Parser Parser;
typedef struct _ParserClass ParserClass;
typedef struct _ParserPrivate ParserPrivate;

#define TYPE_LEXER (lexer_get_type ())
#define LEXER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_LEXER, Lexer))
#define LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_LEXER, LexerClass))
#define IS_LEXER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_LEXER))
#define IS_LEXER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_LEXER))
#define LEXER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_LEXER, LexerClass))

typedef struct _Lexer Lexer;
typedef struct _LexerClass LexerClass;

#define TYPE_TOKEN (token_get_type ())
#define TOKEN(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_TOKEN, Token))
#define TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_TOKEN, TokenClass))
#define IS_TOKEN(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_TOKEN))
#define IS_TOKEN_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_TOKEN))
#define TOKEN_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_TOKEN, TokenClass))

typedef struct _Token Token;
typedef struct _TokenClass TokenClass;
#define _lexer_unref0(var) ((var == NULL) ? NULL : (var = (lexer_unref (var), NULL)))
#define _token_unref0(var) ((var == NULL) ? NULL : (var = (token_unref (var), NULL)))

#define TYPE_AST_NODE (ast_node_get_type ())
#define AST_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_AST_NODE, AstNode))
#define AST_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_AST_NODE, AstNodeClass))
#define IS_AST_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_AST_NODE))
#define IS_AST_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_AST_NODE))
#define AST_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_AST_NODE, AstNodeClass))

typedef struct _AstNode AstNode;
typedef struct _AstNodeClass AstNodeClass;

#define TYPE_FUNCTION_NODE (function_node_get_type ())
#define FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_FUNCTION_NODE, FunctionNode))
#define FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_FUNCTION_NODE, FunctionNodeClass))
#define IS_FUNCTION_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_FUNCTION_NODE))
#define IS_FUNCTION_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_FUNCTION_NODE))
#define FUNCTION_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_FUNCTION_NODE, FunctionNodeClass))

typedef struct _FunctionNode FunctionNode;
typedef struct _FunctionNodeClass FunctionNodeClass;
typedef enum  {
	TOKEN_TYPE_IDENTIFIER,
	TOKEN_TYPE_KEYWORD,
	TOKEN_TYPE_NUMBER,
	TOKEN_TYPE_STRING,
	TOKEN_TYPE_SYMBOL,
	TOKEN_TYPE_END_OF_FILE,
	TOKEN_TYPE_UNKNOWN
} TokenType;

#define TYPE_TOKEN_TYPE (token_type_get_type ())
typedef struct _TokenPrivate TokenPrivate;

#define TYPE_PARAMETER (parameter_get_type ())
#define PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_PARAMETER, Parameter))
#define PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_PARAMETER, ParameterClass))
#define IS_PARAMETER(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_PARAMETER))
#define IS_PARAMETER_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_PARAMETER))
#define PARAMETER_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_PARAMETER, ParameterClass))

typedef struct _Parameter Parameter;
typedef struct _ParameterClass ParameterClass;
#define _g_free0(var) (var = (g_free (var), NULL))

#define TYPE_BLOCK_NODE (block_node_get_type ())
#define BLOCK_NODE(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_BLOCK_NODE, BlockNode))
#define BLOCK_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_BLOCK_NODE, BlockNodeClass))
#define IS_BLOCK_NODE(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_BLOCK_NODE))
#define IS_BLOCK_NODE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_BLOCK_NODE))
#define BLOCK_NODE_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_BLOCK_NODE, BlockNodeClass))

typedef struct _BlockNode BlockNode;
typedef struct _BlockNodeClass BlockNodeClass;
typedef struct _AstNodePrivate AstNodePrivate;
typedef struct _BlockNodePrivate BlockNodePrivate;
#define _ast_node_unref0(var) ((var == NULL) ? NULL : (var = (ast_node_unref (var), NULL)))
typedef struct _ParamSpecParser ParamSpecParser;

struct _Parser {
	GTypeInstance parent_instance;
	volatile int ref_count;
	ParserPrivate * priv;
};

struct _ParserClass {
	GTypeClass parent_class;
	void (*finalize) (Parser *self);
};

struct _ParserPrivate {
	Lexer* lexer;
	Token* current;
};

struct _Token {
	GTypeInstance parent_instance;
	volatile int ref_count;
	TokenPrivate * priv;
	TokenType type;
	gchar* lexeme;
	gint line;
};

struct _TokenClass {
	GTypeClass parent_class;
	void (*finalize) (Token *self);
};

struct _AstNode {
	GTypeInstance parent_instance;
	volatile int ref_count;
	AstNodePrivate * priv;
};

struct _AstNodeClass {
	GTypeClass parent_class;
	void (*finalize) (AstNode *self);
	void (*print) (AstNode* self, gint indent);
};

struct _BlockNode {
	AstNode parent_instance;
	BlockNodePrivate * priv;
	GList* statements;
};

struct _BlockNodeClass {
	AstNodeClass parent_class;
};

struct _ParamSpecParser {
	GParamSpec parent_instance;
};

static gint Parser_private_offset;
static gpointer parser_parent_class = NULL;

VALA_EXTERN gpointer parser_ref (gpointer instance);
VALA_EXTERN void parser_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_parser (const gchar* name,
                               const gchar* nick,
                               const gchar* blurb,
                               GType object_type,
                               GParamFlags flags);
VALA_EXTERN void value_set_parser (GValue* value,
                       gpointer v_object);
VALA_EXTERN void value_take_parser (GValue* value,
                        gpointer v_object);
VALA_EXTERN gpointer value_get_parser (const GValue* value);
VALA_EXTERN GType parser_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Parser, parser_unref)
VALA_EXTERN gpointer lexer_ref (gpointer instance);
VALA_EXTERN void lexer_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_lexer (const gchar* name,
                              const gchar* nick,
                              const gchar* blurb,
                              GType object_type,
                              GParamFlags flags);
VALA_EXTERN void value_set_lexer (GValue* value,
                      gpointer v_object);
VALA_EXTERN void value_take_lexer (GValue* value,
                       gpointer v_object);
VALA_EXTERN gpointer value_get_lexer (const GValue* value);
VALA_EXTERN GType lexer_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Lexer, lexer_unref)
VALA_EXTERN gpointer token_ref (gpointer instance);
VALA_EXTERN void token_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_token (const gchar* name,
                              const gchar* nick,
                              const gchar* blurb,
                              GType object_type,
                              GParamFlags flags);
VALA_EXTERN void value_set_token (GValue* value,
                      gpointer v_object);
VALA_EXTERN void value_take_token (GValue* value,
                       gpointer v_object);
VALA_EXTERN gpointer value_get_token (const GValue* value);
VALA_EXTERN GType token_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Token, token_unref)
VALA_EXTERN Parser* parser_new (Lexer* lexer);
VALA_EXTERN Parser* parser_construct (GType object_type,
                          Lexer* lexer);
VALA_EXTERN Token* lexer_next_token (Lexer* self);
VALA_EXTERN gpointer ast_node_ref (gpointer instance);
VALA_EXTERN void ast_node_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_ast_node (const gchar* name,
                                 const gchar* nick,
                                 const gchar* blurb,
                                 GType object_type,
                                 GParamFlags flags);
VALA_EXTERN void value_set_ast_node (GValue* value,
                         gpointer v_object);
VALA_EXTERN void value_take_ast_node (GValue* value,
                          gpointer v_object);
VALA_EXTERN gpointer value_get_ast_node (const GValue* value);
VALA_EXTERN GType ast_node_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (AstNode, ast_node_unref)
VALA_EXTERN GType function_node_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (FunctionNode, ast_node_unref)
VALA_EXTERN FunctionNode* parser_parse_function (Parser* self);
VALA_EXTERN GType token_type_get_type (void) G_GNUC_CONST ;
static Token* parser_consume (Parser* self,
                       TokenType expected);
static void parser_consume_symbol (Parser* self,
                            const gchar* symbol);
VALA_EXTERN gpointer parameter_ref (gpointer instance);
VALA_EXTERN void parameter_unref (gpointer instance);
VALA_EXTERN GParamSpec* param_spec_parameter (const gchar* name,
                                  const gchar* nick,
                                  const gchar* blurb,
                                  GType object_type,
                                  GParamFlags flags);
VALA_EXTERN void value_set_parameter (GValue* value,
                          gpointer v_object);
VALA_EXTERN void value_take_parameter (GValue* value,
                           gpointer v_object);
VALA_EXTERN gpointer value_get_parameter (const GValue* value);
VALA_EXTERN GType parameter_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (Parameter, parameter_unref)
static gboolean parser_check_symbol (Parser* self,
                              const gchar* symbol);
static gboolean parser_match_symbol (Parser* self,
                              const gchar* symbol);
VALA_EXTERN Parameter* parameter_new (const gchar* type,
                          const gchar* name);
VALA_EXTERN Parameter* parameter_construct (GType object_type,
                                const gchar* type,
                                const gchar* name);
VALA_EXTERN GType block_node_get_type (void) G_GNUC_CONST ;
G_DEFINE_AUTOPTR_CLEANUP_FUNC (BlockNode, ast_node_unref)
VALA_EXTERN BlockNode* block_node_new (void);
VALA_EXTERN BlockNode* block_node_construct (GType object_type);
static void parser_advance (Parser* self);
VALA_EXTERN FunctionNode* function_node_new (const gchar* return_type,
                                 const gchar* name,
                                 GList* parameters,
                                 BlockNode* body);
VALA_EXTERN FunctionNode* function_node_construct (GType object_type,
                                       const gchar* return_type,
                                       const gchar* name,
                                       GList* parameters,
                                       BlockNode* body);
static void _parameter_unref0_ (gpointer var);
static inline void _g_list_free__parameter_unref0_ (GList* self);
VALA_EXTERN Token* token_new (TokenType type,
                  const gchar* lexeme,
                  gint line);
VALA_EXTERN Token* token_construct (GType object_type,
                        TokenType type,
                        const gchar* lexeme,
                        gint line);
static void parser_finalize (Parser * obj);
static GType parser_get_type_once (void);

static inline gpointer
parser_get_instance_private (Parser* self)
{
	return G_STRUCT_MEMBER_P (self, Parser_private_offset);
}

static gpointer
_lexer_ref0 (gpointer self)
{
	return self ? lexer_ref (self) : NULL;
}

Parser*
parser_construct (GType object_type,
                  Lexer* lexer)
{
	Parser* self = NULL;
	Lexer* _tmp0_;
	Token* _tmp1_;
	g_return_val_if_fail (lexer != NULL, NULL);
	self = (Parser*) g_type_create_instance (object_type);
	_tmp0_ = _lexer_ref0 (lexer);
	_lexer_unref0 (self->priv->lexer);
	self->priv->lexer = _tmp0_;
	_tmp1_ = lexer_next_token (lexer);
	_token_unref0 (self->priv->current);
	self->priv->current = _tmp1_;
	return self;
}

Parser*
parser_new (Lexer* lexer)
{
	return parser_construct (TYPE_PARSER, lexer);
}

static void
_parameter_unref0_ (gpointer var)
{
	(var == NULL) ? NULL : (var = (parameter_unref (var), NULL));
}

static inline void
_g_list_free__parameter_unref0_ (GList* self)
{
	g_list_free_full (self, (GDestroyNotify) _parameter_unref0_);
}

FunctionNode*
parser_parse_function (Parser* self)
{
	gchar* return_type = NULL;
	Token* _tmp0_;
	Token* _tmp1_;
	const gchar* _tmp2_;
	gchar* _tmp3_;
	gchar* _tmp4_;
	gchar* name = NULL;
	Token* _tmp5_;
	Token* _tmp6_;
	const gchar* _tmp7_;
	gchar* _tmp8_;
	gchar* _tmp9_;
	GList* parameters = NULL;
	BlockNode* body = NULL;
	BlockNode* _tmp24_;
	const gchar* _tmp29_;
	const gchar* _tmp30_;
	GList* _tmp31_;
	BlockNode* _tmp32_;
	FunctionNode* _tmp33_;
	FunctionNode* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = parser_consume (self, TOKEN_TYPE_IDENTIFIER);
	_tmp1_ = _tmp0_;
	_tmp2_ = _tmp1_->lexeme;
	_tmp3_ = g_strdup (_tmp2_);
	_tmp4_ = _tmp3_;
	_token_unref0 (_tmp1_);
	return_type = _tmp4_;
	_tmp5_ = parser_consume (self, TOKEN_TYPE_IDENTIFIER);
	_tmp6_ = _tmp5_;
	_tmp7_ = _tmp6_->lexeme;
	_tmp8_ = g_strdup (_tmp7_);
	_tmp9_ = _tmp8_;
	_token_unref0 (_tmp6_);
	name = _tmp9_;
	parser_consume_symbol (self, "(");
	parameters = NULL;
	if (!parser_check_symbol (self, ")")) {
		{
			gboolean _tmp10_ = FALSE;
			_tmp10_ = TRUE;
			while (TRUE) {
				gchar* type = NULL;
				Token* _tmp11_;
				Token* _tmp12_;
				const gchar* _tmp13_;
				gchar* _tmp14_;
				gchar* _tmp15_;
				gchar* pname = NULL;
				Token* _tmp16_;
				Token* _tmp17_;
				const gchar* _tmp18_;
				gchar* _tmp19_;
				gchar* _tmp20_;
				const gchar* _tmp21_;
				const gchar* _tmp22_;
				Parameter* _tmp23_;
				if (!_tmp10_) {
					if (!parser_match_symbol (self, ",")) {
						break;
					}
				}
				_tmp10_ = FALSE;
				_tmp11_ = parser_consume (self, TOKEN_TYPE_IDENTIFIER);
				_tmp12_ = _tmp11_;
				_tmp13_ = _tmp12_->lexeme;
				_tmp14_ = g_strdup (_tmp13_);
				_tmp15_ = _tmp14_;
				_token_unref0 (_tmp12_);
				type = _tmp15_;
				_tmp16_ = parser_consume (self, TOKEN_TYPE_IDENTIFIER);
				_tmp17_ = _tmp16_;
				_tmp18_ = _tmp17_->lexeme;
				_tmp19_ = g_strdup (_tmp18_);
				_tmp20_ = _tmp19_;
				_token_unref0 (_tmp17_);
				pname = _tmp20_;
				_tmp21_ = type;
				_tmp22_ = pname;
				_tmp23_ = parameter_new (_tmp21_, _tmp22_);
				parameters = g_list_append (parameters, _tmp23_);
				_g_free0 (pname);
				_g_free0 (type);
			}
		}
	}
	parser_consume_symbol (self, ")");
	parser_consume_symbol (self, "{");
	_tmp24_ = block_node_new ();
	body = _tmp24_;
	while (TRUE) {
		BlockNode* _tmp25_;
		Token* _tmp26_;
		const gchar* _tmp27_;
		gchar* _tmp28_;
		if (!(!parser_check_symbol (self, "}"))) {
			break;
		}
		_tmp25_ = body;
		_tmp26_ = self->priv->current;
		_tmp27_ = _tmp26_->lexeme;
		_tmp28_ = g_strdup (_tmp27_);
		_tmp25_->statements = g_list_append (_tmp25_->statements, _tmp28_);
		parser_advance (self);
	}
	parser_consume_symbol (self, "}");
	_tmp29_ = return_type;
	_tmp30_ = name;
	_tmp31_ = parameters;
	_tmp32_ = body;
	_tmp33_ = function_node_new (_tmp29_, _tmp30_, _tmp31_, _tmp32_);
	result = _tmp33_;
	_ast_node_unref0 (body);
	(parameters == NULL) ? NULL : (parameters = (_g_list_free__parameter_unref0_ (parameters), NULL));
	_g_free0 (name);
	_g_free0 (return_type);
	return result;
}

static gpointer
_token_ref0 (gpointer self)
{
	return self ? token_ref (self) : NULL;
}

static Token*
parser_consume (Parser* self,
                TokenType expected)
{
	Token* _tmp0_;
	Token* result;
	g_return_val_if_fail (self != NULL, NULL);
	_tmp0_ = self->priv->current;
	if (_tmp0_->type == expected) {
		Token* tmp = NULL;
		Token* _tmp1_;
		Token* _tmp2_;
		_tmp1_ = self->priv->current;
		_tmp2_ = _token_ref0 (_tmp1_);
		tmp = _tmp2_;
		parser_advance (self);
		result = tmp;
		return result;
	} else {
		FILE* _tmp3_;
		GEnumValue* _tmp4_;
		Token* _tmp5_;
		const gchar* _tmp6_;
		Token* _tmp7_;
		const gchar* _tmp8_;
		Token* _tmp9_;
		Token* _tmp10_;
		_tmp3_ = stderr;
		_tmp4_ = g_enum_get_value (g_type_class_ref (TYPE_TOKEN_TYPE), expected);
		_tmp5_ = self->priv->current;
		_tmp6_ = _tmp5_->lexeme;
		fprintf (_tmp3_, "Expected %s but found %s\n", (_tmp4_ != NULL) ? _tmp4_->value_name : NULL, _tmp6_);
		_tmp7_ = self->priv->current;
		_tmp8_ = _tmp7_->lexeme;
		_tmp9_ = self->priv->current;
		_tmp10_ = token_new (TOKEN_TYPE_UNKNOWN, _tmp8_, _tmp9_->line);
		result = _tmp10_;
		return result;
	}
}

static void
parser_consume_symbol (Parser* self,
                       const gchar* symbol)
{
	Token* _tmp0_;
	const gchar* _tmp1_;
	g_return_if_fail (self != NULL);
	g_return_if_fail (symbol != NULL);
	_tmp0_ = self->priv->current;
	_tmp1_ = _tmp0_->lexeme;
	if (g_strcmp0 (_tmp1_, symbol) == 0) {
		parser_advance (self);
	} else {
		FILE* _tmp2_;
		Token* _tmp3_;
		const gchar* _tmp4_;
		_tmp2_ = stderr;
		_tmp3_ = self->priv->current;
		_tmp4_ = _tmp3_->lexeme;
		fprintf (_tmp2_, "Expected symbol '%s' but found '%s'\n", symbol, _tmp4_);
	}
}

static gboolean
parser_match_symbol (Parser* self,
                     const gchar* symbol)
{
	Token* _tmp0_;
	const gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (symbol != NULL, FALSE);
	_tmp0_ = self->priv->current;
	_tmp1_ = _tmp0_->lexeme;
	if (g_strcmp0 (_tmp1_, symbol) == 0) {
		parser_advance (self);
		result = TRUE;
		return result;
	}
	result = FALSE;
	return result;
}

static gboolean
parser_check_symbol (Parser* self,
                     const gchar* symbol)
{
	Token* _tmp0_;
	const gchar* _tmp1_;
	gboolean result;
	g_return_val_if_fail (self != NULL, FALSE);
	g_return_val_if_fail (symbol != NULL, FALSE);
	_tmp0_ = self->priv->current;
	_tmp1_ = _tmp0_->lexeme;
	result = g_strcmp0 (_tmp1_, symbol) == 0;
	return result;
}

static void
parser_advance (Parser* self)
{
	Lexer* _tmp0_;
	Token* _tmp1_;
	g_return_if_fail (self != NULL);
	_tmp0_ = self->priv->lexer;
	_tmp1_ = lexer_next_token (_tmp0_);
	_token_unref0 (self->priv->current);
	self->priv->current = _tmp1_;
}

static void
value_parser_init (GValue* value)
{
	value->data[0].v_pointer = NULL;
}

static void
value_parser_free_value (GValue* value)
{
	if (value->data[0].v_pointer) {
		parser_unref (value->data[0].v_pointer);
	}
}

static void
value_parser_copy_value (const GValue* src_value,
                         GValue* dest_value)
{
	if (src_value->data[0].v_pointer) {
		dest_value->data[0].v_pointer = parser_ref (src_value->data[0].v_pointer);
	} else {
		dest_value->data[0].v_pointer = NULL;
	}
}

static gpointer
value_parser_peek_pointer (const GValue* value)
{
	return value->data[0].v_pointer;
}

static gchar*
value_parser_collect_value (GValue* value,
                            guint n_collect_values,
                            GTypeCValue* collect_values,
                            guint collect_flags)
{
	if (collect_values[0].v_pointer) {
		Parser * object;
		object = collect_values[0].v_pointer;
		if (object->parent_instance.g_class == NULL) {
			return g_strconcat ("invalid unclassed object pointer for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		} else if (!g_value_type_compatible (G_TYPE_FROM_INSTANCE (object), G_VALUE_TYPE (value))) {
			return g_strconcat ("invalid object type `", g_type_name (G_TYPE_FROM_INSTANCE (object)), "' for value type `", G_VALUE_TYPE_NAME (value), "'", NULL);
		}
		value->data[0].v_pointer = parser_ref (object);
	} else {
		value->data[0].v_pointer = NULL;
	}
	return NULL;
}

static gchar*
value_parser_lcopy_value (const GValue* value,
                          guint n_collect_values,
                          GTypeCValue* collect_values,
                          guint collect_flags)
{
	Parser ** object_p;
	object_p = collect_values[0].v_pointer;
	if (!object_p) {
		return g_strdup_printf ("value location for `%s' passed as NULL", G_VALUE_TYPE_NAME (value));
	}
	if (!value->data[0].v_pointer) {
		*object_p = NULL;
	} else if (collect_flags & G_VALUE_NOCOPY_CONTENTS) {
		*object_p = value->data[0].v_pointer;
	} else {
		*object_p = parser_ref (value->data[0].v_pointer);
	}
	return NULL;
}

GParamSpec*
param_spec_parser (const gchar* name,
                   const gchar* nick,
                   const gchar* blurb,
                   GType object_type,
                   GParamFlags flags)
{
	ParamSpecParser* spec;
	g_return_val_if_fail (g_type_is_a (object_type, TYPE_PARSER), NULL);
	spec = g_param_spec_internal (G_TYPE_PARAM_OBJECT, name, nick, blurb, flags);
	G_PARAM_SPEC (spec)->value_type = object_type;
	return G_PARAM_SPEC (spec);
}

gpointer
value_get_parser (const GValue* value)
{
	g_return_val_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER), NULL);
	return value->data[0].v_pointer;
}

void
value_set_parser (GValue* value,
                  gpointer v_object)
{
	Parser * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
		parser_ref (value->data[0].v_pointer);
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}

void
value_take_parser (GValue* value,
                   gpointer v_object)
{
	Parser * old;
	g_return_if_fail (G_TYPE_CHECK_VALUE_TYPE (value, TYPE_PARSER));
	old = value->data[0].v_pointer;
	if (v_object) {
		g_return_if_fail (G_TYPE_CHECK_INSTANCE_TYPE (v_object, TYPE_PARSER));
		g_return_if_fail (g_value_type_compatible (G_TYPE_FROM_INSTANCE (v_object), G_VALUE_TYPE (value)));
		value->data[0].v_pointer = v_object;
	} else {
		value->data[0].v_pointer = NULL;
	}
	if (old) {
		parser_unref (old);
	}
}

static void
parser_class_init (ParserClass * klass,
                   gpointer klass_data)
{
	parser_parent_class = g_type_class_peek_parent (klass);
	((ParserClass *) klass)->finalize = parser_finalize;
	g_type_class_adjust_private_offset (klass, &Parser_private_offset);
}

static void
parser_instance_init (Parser * self,
                      gpointer klass)
{
	self->priv = parser_get_instance_private (self);
	self->ref_count = 1;
}

static void
parser_finalize (Parser * obj)
{
	Parser * self;
	self = G_TYPE_CHECK_INSTANCE_CAST (obj, TYPE_PARSER, Parser);
	g_signal_handlers_destroy (self);
	_lexer_unref0 (self->priv->lexer);
	_token_unref0 (self->priv->current);
}

static GType
parser_get_type_once (void)
{
	static const GTypeValueTable g_define_type_value_table = { value_parser_init, value_parser_free_value, value_parser_copy_value, value_parser_peek_pointer, "p", value_parser_collect_value, "p", value_parser_lcopy_value };
	static const GTypeInfo g_define_type_info = { sizeof (ParserClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) parser_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (Parser), 0, (GInstanceInitFunc) parser_instance_init, &g_define_type_value_table };
	static const GTypeFundamentalInfo g_define_type_fundamental_info = { (G_TYPE_FLAG_CLASSED | G_TYPE_FLAG_INSTANTIATABLE | G_TYPE_FLAG_DERIVABLE | G_TYPE_FLAG_DEEP_DERIVABLE) };
	GType parser_type_id;
	parser_type_id = g_type_register_fundamental (g_type_fundamental_next (), "Parser", &g_define_type_info, &g_define_type_fundamental_info, 0);
	Parser_private_offset = g_type_add_instance_private (parser_type_id, sizeof (ParserPrivate));
	return parser_type_id;
}

GType
parser_get_type (void)
{
	static volatile gsize parser_type_id__once = 0;
	if (g_once_init_enter (&parser_type_id__once)) {
		GType parser_type_id;
		parser_type_id = parser_get_type_once ();
		g_once_init_leave (&parser_type_id__once, parser_type_id);
	}
	return parser_type_id__once;
}

gpointer
parser_ref (gpointer instance)
{
	Parser * self;
	self = instance;
	g_atomic_int_inc (&self->ref_count);
	return instance;
}

void
parser_unref (gpointer instance)
{
	Parser * self;
	self = instance;
	if (g_atomic_int_dec_and_test (&self->ref_count)) {
		PARSER_GET_CLASS (self)->finalize (self);
		g_type_free_instance ((GTypeInstance *) self);
	}
}

